# Directed Greybox Fuzzing

### Figure 1

```c
1455 + /* Read type and payload length first */
1456 + hbtype = *p++;
1457 + n2s(p, payload);
1458 + pl = p;
· · ·
1465 + if (hbtype == TLS1_HB_REQUEST) {
1477 + /* Enter response type, length and copy payload */
1478 + *bp++ = TLS1_HB_RESPONSE;
1479 + s2n(payload, bp);
1480 + memcpy(bp, pl, payload);
```

> Figure 1: Commit introducing Heartbleed: After reading the payload from the incoming message p (1455-8), it copies payload many bytes from the incoming to the outgoing message. If payload is set to 64kb and the incoming message is one byte long, the sender reveals up to ∼64kb of private data.

### Figure 2

![](http://ww1.sinaimg.cn/large/006AWYXBly1fowitpkcwqj30en099dgc.jpg)



- Generage inputs with the objective of reaching a given set of target program location efficiently.
- assigns more energy to seeds that are closer to the target locations while reducing energy for seeds that are futher away.(simulated annealing-based)
- new inputs are generated by mutating a provided seed input and added to the fuzzer's queue if they exercise a new and interesting path.
- directed symbolic is very effective.
- however the effectiveness of such whitebox fuzzers comes at the cost of efficiency.
- DGF is focused on reaching a given set of target location in a program.
- we cast reachability as an optimization problem and employ a specific meta-heuristic to minimize the distance of the generated seeds to the targets
- the meta-heuristic that DGF employs to minimize seed distance is called simulated annealing and is implemented as power schedule.
- a power schedule controls the energy of all seeds
- a seed's energy specifies the time spent fuzzing the seed.
- a seed's energy specifies the time spent fuzzing the seed.
- Like wth all greybox fuzzing techniques, by moving the analysis to compile-time, we minimize the overhead at runtime.



## To compute seed distance

1. first compute and instrument the distance of each basic block to the targets

   > while seed distance is inter-procedural, our novel measure requires analysis only once for the call graph and once per intra-procedural CFG.

2. at runtime, the fuzzer aggregates the distance values of each exercised basic block to compute the seed distance values of each exercised basic block to compute the seed distance as their mean.

- Directed greybox fuzzing is effectively directed and efficiently complements symbolic execution-based directed fuzzing.

- directed greybox fuzzing is useful in the domains of patch testing and crash reproduction.

- GoAFL is an useful path testing tool that effectively exposes vulnerabilities that were recently introduced and incomplete fixes of previously reported vulnerabilities.

- for each target ***t***, KATCH executes the following greedy search: KATCH identifies a seed ***s*** in the regression test suite that is "closest" to ***t***.

- GoAFL randomly mutates the provided seeds to generate many new inputs. If a new input increase the code coverage, it is added to the set of seeds to be fuzzed. otherwise, it is discarded.

- the provided and generated seeds are fuzzed in a continuous loop.

- the time when GoAFL enters exploitation is specified by the user.

- DGF retins the efficiency of greybox fuzzing because it does not conduct any program analysis during runtime since all program analysis is conducted at compile-time.

- Black-box fuzzing only requires the program to execute. White-box fuzzing based on symbolic execution requires heavy-weight program analysis and requires heavy-weight program analysis and constraint solving. Greybox fuzzing is placed in-between and used only light-weight instrumentation to glean some program structure.

- WIthout program analysis, greybox fuzzing may be more efficient than white-box fuzzing. 

- With more information about internal structure, it may be more effective than blackbox fuzzing.

- how CGF(Coverage-based fuzzer) works

  ![深度截图_选择区域_20180303151442](../../../../home/m4x/my_repo/DGF/Pics/深度截图_选择区域_20180303151442.png)

  ​

- 马尔科夫链：

  > **马尔可夫链**（英语：Markov chain），又称**离散时间马尔可夫链**（discrete-time Markov chain，缩写为**DTMC**[[1\]](https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE#cite_note-1)），因俄国数学家[安德烈·马尔可夫](https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB)（俄语：Андрей Андреевич Марков）得名，为[状态空间](https://zh.wikipedia.org/wiki/%E7%8B%80%E6%85%8B%E7%A9%BA%E9%96%93_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))中经过从一个状态到另一个状态的转换的[随机过程](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B)。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作[马尔可夫性质](https://zh.wikipedia.org/wiki/%E9%A6%AC%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B3%AA)。马尔科夫链作为实际过程的统计模型具有许多应用。

- Note that the energy is a propery that is local to a state in the Markov chain unlike temperature which is global in simulated annealing.

- In order to compute distance accross functions, we assign a value to each node in the call graph(CG) on function-level and in the intraprocedural control-flow graphs on bacis-block level.


## Architetecture

![](http://ww1.sinaimg.cn/large/006AWYXBly1fp1tmk7netj30py07kq3o.jpg)

> Architecture: After the Graph Extractor generates the call and control-flow graphs from the source code, the distance calculator computes the basic-block-level target distance for each basic block which is used by the Instrumentor during intrumentation. The instrumented binary informs the Fuzzer not only about coverage but also about the seed distance.

- The GoAFL Graph Extractor(GE) generates the call graph(CG) and the revelent control-flow graphs(CFGs). 
- **CG nodes are identified by the function signature while CFG nodes are identified by the function signature**
- **CFG nodes are identified by the source file and line of the first statement of the corresponding basic block**
- The tarmpoline is a piece of assembly code that is executed after each jump instruction to keep track of the covered control-flow edges.